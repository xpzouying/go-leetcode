package decode_ways

import "strconv"

func numDecodings(s string) int {
	l := len(s)
	if l == 0 {
		return 0
	}

	// DP 保存到该下标（不包括）的编码方法的总数
	DP := make([]int, l+1)
	DP[0] = 1
	if s[0] == '0' {
		DP[1] = 0
	} else {
		DP[1] = 1
	}

	for i := 2; i <= len(s); i++ {

		if s[i-1] != '0' {
			// 可以使用最后一个字符进行编码
			DP[i] += DP[i-1]
		}

		// 判断是否如何使用最后两位字符编码

		// 如果是01、02、。。。、09，是不可以的
		d := strToInt(s[i-2 : i])
		if d >= 10 && d <= 26 {
			DP[i] += DP[i-2]
		}
	}

	return DP[len(DP)-1]
}

func strToInt(s string) int {
	v, _ := strconv.Atoi(s)
	return v
}

/**

### 解题思路

**线索：**

要求解码方式的总数，是一道动态规划的题目的线索。

状态转移：

DP记录解码方法的总数，

DP[i]为字符串到第i-1个字符串时的总数，

DP表格的长度为：len(s)+1，加1的原因是最后一个字符串也编码结束。

由于编码最多是变化成2为字符，所以可以假设转移方程需要分析最后2个字符。



如果最后一个字符可以进行编码并且最后两个字符也可以编码才适用，比如11，12，26等，

能够获得最佳解：

DP[i] = DP[i-1] + DP[i-2]

总结各种情况，

1. 如果最后一位不为0，那么：DP[i] += DP[i-1]

2. 如果最后一位为0，那么不用单独考虑DP[i-1]，因为形成不了有效编码

3. 考虑最后两位字符，对应的整型假设为：d

3.1 如果 10 <= d <=26，是有效编码，则
	DP[i] += DP[i-2]
3.2 否则无效编码，不能累加DP[i-2]

初始化：

由于需要涉及到前面两位DP，所以初始化DP[0], DP[1]

DP[0] = 1
DP[1] =
	0, 如果s[0] == '0'，因为0没有对应的编码，1是第一个编码，对应的是A
	1，如果s[0] != '0'

*/
